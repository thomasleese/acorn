import 'base/memory'

type Array{T}
    elements as UnsafePointer{T}
    length as Integer
    capacity as Integer
end

def create_array{T}(t as Type{T}, capacity as Integer) as Array{T}
    let elements = malloc(strideof(T) * capacity) as UnsafePointer{T}
    return new Array{T}(elements: elements, size: 0, capacity: capacity)
end

def free{T}(inout array as Array{T}) as Void
    free(array.elements)
end

def setindex{T}(inout array as Array{T}, key as Integer, value as T) as Void
    array.elements[key] = value
end

def getindex{T}(array as Array{T}, key as Integer) as T
    return array.elements[key]
end

def append{T}(inout array as Array{T}, value as T) as Void
    array.length = array.length + 1
    array[array.length - 1] = value
end

type _ArrayState as Integer

def start{T}(array as Array{T}) as _ArrayState
    return 0
end

def next{T}(array as Array{T}, state as _ArrayState) as Tuple{T, _ArrayState}
    return array[state], state + 1
end

def done{T}(array as Array{T}, state as _ArrayState) as Boolean
    return state >= array.length
end

def sum(iterator as Array{Integer}) as Integer
    let total = 0

    # iterator over values
    let i = 0
    for i in iterator
        total += i
    end

    return total
end


type Enumeration{T}
    array as Array{T}
end

def enumerate{T}(array as Array{T}) as Enumeration{T}
    return new Enumeration{T}(array: array)
end

def start{T}(enumeration as Enumeration{T}) as Integer
    return 0
end

def next{T}(enumeration as Enumeration{T}, state as Integer) as Tuple{Tuple{Integer, T}, _ArrayState}
    return (state, enumeration.array[state]), state + 1
end

def done{T}(enumeration as Enumeration{T}, state as Integer) as Boolean
    return state >= enumeration.array.length
end
