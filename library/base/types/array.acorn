import 'base/memory'

type Array{T}
    elements as UnsafePointer{T}
    length as Integer
    capacity as Integer
end

def create_array{T}(t as Type{T}, capacity as Integer) as Array{T}
    let elements = malloc(strideof(T) * capacity) as UnsafePointer{T}
    return new Array{T}(elements: elements, size: 0, capacity: capacity)
end

def free{T}(inout array as Array{T}) as Void
    free(array.elements)
end

def setindex{T}(inout array as Array{T}, key as Integer, value as T) as Void
    array.elements[key] = value
end

def getindex{T}(array as Array{T}, key as Integer) as T
    return array.elements[key]
end

def append{T}(inout array as Array{T}, value as T) as Void
    array.length = array.length + 1
    array[array.length - 1] = value
end

type ArrayIterator{T}
    array as Array{T}
    state as Integer
end

def iterate{T}(array as Array{T}) as ArrayIterator{T}
    return new ArrayIterator{T}(array: array, state: 0)
end

def next{T}(iterator as ArrayIterator{T}) as Maybe{T}
    if iterator.state >= iterator.array.length
        let result as Maybe{T} = Nothing
        return result
    else
        iterator.state += 1
        return iterator.array[iterator.state]
    end
end

def sum(array as Array{Integer}) as Integer
    let total = 0

    # iterator over values
    #let iterator = iterate(array)
    #while let i as Integer = iterator.next()
    #    total += i
    #end

    return total
end


type Enumeration{T}
    iterator as ArrayIterator{T}
    state as Integer
end

def enumerate{T}(array as Array{T}) as Enumeration{T}
    return new Enumeration{T}(array: array.iterate(), state: 0)
end

def next{T}(enumeration as Enumeration{T}) as Maybe{Tuple{Integer, T}}
    let item = next(enumeration.iterator)
    if let n as Void = item
        return Nothing
    else
        enumeration.state += 1
        return (item, enumeration.state)
    end
end
